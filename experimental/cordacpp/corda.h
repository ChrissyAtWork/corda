#include <utility>

#ifndef CORDA_H
#define CORDA_H

#include <iostream>
#include <map>
#include <fstream>
#include <sstream>

#include <proton/codec/decoder.hpp>
#include <proton/types.hpp>

namespace net {
namespace corda {

// TODO: Map kotlin.Pair to std::pair

/**
 * The root class of a generated message hierarchy. Does nothing, but is useful for code generation.
 */
class Any {
public:
    virtual ~Any() {};   // Must have at least one virtual function to force vtable generation.
};

/**
 * We define a custom name for std::unique_ptr so that we can distinguish in the type system fields that are meant to
 * be coming from the deserialisation engine. This allows us to define overloads to adapt Proton deserialisation to
 * the generated classes, which expect to be given the decoder as a constructor input.
 *
 * @tparam T
 */
template<class T>
class ptr : public std::shared_ptr<T> {
public:
    explicit ptr(T *p) : std::shared_ptr<T>(p) {}

    ptr() : std::shared_ptr<T>() {}
};

enum SchemaDescriptor {
    UNKNOWN = -1,
    ENVELOPE = 1,
    SCHEMA = 2,
    OBJECT_DESCRIPTOR = 3,
    FIELD = 4,
    COMPOSITE_TYPE = 5,
    RESTRICTED_TYPE = 6,
    CHOICE = 7,
    REFERENCED_OBJECT = 8,
    TRANSFORM_SCHEMA = 9,
    TRANSFORM_ELEMENT = 10,
    TRANSFORM_ELEMENT_KEY = 11
};

/**
 * Parses a serialised Corda AMQP message into classes generated by the generate-serialization-libs tool.
 *
 * Can also convert the given message into a debug string dump.
 */
class Parser {
public:
    static __thread Parser* current;

    explicit Parser(const std::string &bytes) : indent_(0), bytes(bytes) {};

    /** Returns a string containing a multi-line debug representation of the message stream. */
    std::string dump();

    template<class T>
    std::shared_ptr<T> parse() {
        try {
            current = this;
            proton::codec::decoder decoder = prepare_decoder();
            ptr<T> t;
            decoder >> t;
            decoder >> proton::codec::finish();
            current = nullptr;
            return t;
        } catch (const std::invalid_argument &e) {
            current = nullptr;
            throw e;
        };
    }

    template<class T>
    inline static void read_to(proton::codec::decoder &decoder, T &out) {
        decoder >> out;
    }

    // We can't add this additional wrapping without read_to.
    template<class T>
    inline static void read_to(proton::codec::decoder &decoder, std::vector<ptr<T>> &out) {
        // Unwrap the descriptor surrounding the list.
        proton::codec::start start;
        decoder >> start;
        decoder.next();
        decoder >> out;
        decoder >> proton::codec::finish();
        decoder >> proton::codec::finish();
    }

    template<class K, class V>
    inline static void read_to(proton::codec::decoder &decoder, std::map<K, V> &out) {
        // Unwrap the descriptor surrounding the list.
        proton::codec::start start;
        decoder >> start;
        decoder.next();
        decoder >> out;
        decoder >> proton::codec::finish();
        decoder >> proton::codec::finish();
    }

    const std::string lookup(proton::symbol sym) {
        if (schema_mappings.empty())
            resolve_descriptors();

        if (schema_mappings.find(sym) == schema_mappings.end())
            return "";
        else
            return schema_mappings[sym];
    }

private:
    const std::string &bytes;
    std::map<proton::symbol, std::string> schema_mappings;
    void resolve_descriptors();

    // Returns bytes_ but with the header truncated if valid, otherwise throws.
    std::string check_corda_amqp();

    proton::codec::decoder prepare_decoder();

    // Dumping support.
    unsigned long indent_;
    std::stringstream ss;

    void dump_process(proton::codec::decoder &decoder, const std::map<proton::symbol, std::string> &schema_mappings, bool need_indent = true, bool need_newline = true);

    void dump_scalar(proton::codec::decoder &decoder, const proton::type_id &type);

    std::string indent() { return std::string(indent_, ' '); }

    void right() { indent_ += 4; }

    void left() { indent_ -= 4; }

    SchemaDescriptor corda_schema_descriptor_id(unsigned long descriptor) {
        // Descriptor IDs start with 0xc562, this is the R3 IANA assigned enterprise number and is used to avoid
        // integer namespace conflicts.
        if ((descriptor & 0xFFFF000000000000L) != (0xc562L << 48))
            return SchemaDescriptor::UNKNOWN;
        else
            return static_cast<SchemaDescriptor>((int) descriptor & 0xFF);
    }
};

/** A quick convenience for parsing bytes to an object. */
template <class T> inline std::shared_ptr<T> parse(const std::string &bytes) { return Parser(bytes).parse<T>(); }
inline std::string dump(const std::string &bytes) { return Parser(bytes).dump(); }

/**
 * A TypeRegistry maps descriptors to functions that construct objects for them. It allows you to map from descriptor
 * to decoded object. There is a global instance in which the generated code registers itself.
 */
class TypeRegistry {
public:
    static TypeRegistry &GLOBAL();

    typedef std::function<Any*(proton::codec::decoder&)> TypeConstructor;

    void add(const std::string &descriptor, TypeConstructor constructor) {
        registrations.insert(std::make_pair(descriptor, constructor));
    }

    TypeConstructor *get(const std::string &descriptor) {
        if (registrations.find(descriptor) == registrations.end())
            return nullptr;
        else
            return &registrations[descriptor];
    }

private:
    std::map<std::string, TypeConstructor> registrations;
};

/** This class is intended to be instantiated at top level, to auto-register generated types at startup. */
class TypeRegistration {
public:
    explicit TypeRegistration(const char *descriptor, TypeRegistry::TypeConstructor constructor) {
        TypeRegistry::GLOBAL().add(descriptor, constructor);
    }
};

template<class K, class V>
proton::codec::decoder &operator>>(proton::codec::decoder &d, std::map<K, ptr<V>> &r) {
    proton::codec::start s;
    d >> s;
    assert_type_equal(proton::MAP, s.type);
    r.clear();
    for (size_t i = 0; i < s.size / 2; ++i) {
        K k;
        ptr<V> v;
        d >> k >> v;
        r.insert(std::make_pair(k, std::move(v)));
    }
    d >> proton::codec::finish();
    return d;
}

template<class K, class V>
proton::codec::decoder &operator>>(proton::codec::decoder &d, std::map<ptr<K>, ptr<V>> &r) {
    proton::codec::start s;
    d >> s;
    assert_type_equal(proton::MAP, s.type);
    r.clear();
    for (size_t i = 0; i < s.size / 2; ++i) {
        ptr<K> k;
        ptr<V> v;
        d >> k >> v;
        r.insert(std::make_pair(std::move(k), std::move(v)));
    }
    d >> proton::codec::finish();
    return d;
}

template<class K, class V>
proton::codec::decoder &operator>>(proton::codec::decoder &d, std::map<ptr<K>, V> &r) {
    proton::codec::start s;
    d >> s;
    assert_type_equal(proton::MAP, s.type);
    r.clear();
    for (size_t i = 0; i < s.size / 2; ++i) {
        ptr<K> k;
        V v;
        d >> k >> v;
        r.insert(std::make_pair(std::move(k), v));
    }
    d >> proton::codec::finish();
    return d;
}

// Utility to make message formatting a bit less painful. Use like this: msg() << "foo" << bar
struct msg {
    std::ostringstream os;

    msg() {}

    msg(const msg &m) : os(m.str()) {}

    std::string str() const { return os.str(); }

    operator std::string() const { return str(); }

    template<class T>
    msg &operator<<(const T &t) {
        os << t;
        return *this;
    }
};

inline std::ostream &operator<<(std::ostream &o, const msg &m) { return o << m.str(); }

template<class T>
proton::codec::decoder &operator>>(proton::codec::decoder &decoder, ptr<T> &out) {
    // Enter the composite.
    if (decoder.next_type() != proton::DESCRIBED) {
        auto m = msg() << "Expected a described element, but got " << decoder.next_type();
        throw std::invalid_argument(m);
    }
    proton::codec::start start;
    decoder >> start;
    proton::symbol sym;
    decoder >> sym;
    // Composite types have two levels of nesting, the one that contains the "description, thing" pair, and
    // then the list inside "thing", so we have to pop up twice.
    proton::codec::start block;
    decoder >> block;
    // Look up a constructor for the descriptor, if we know it.
    auto ctor = net::corda::TypeRegistry::GLOBAL().get(sym);
    if (ctor == nullptr) {
        const std::string &classname = Parser::current->lookup(sym);
        throw std::invalid_argument(msg() << "Unknown descriptor " << sym << " for '" << classname << "' so cannot construct");
    }
    out = net::corda::ptr<T>(dynamic_cast<T*>((*ctor)(decoder)));
    decoder >> proton::codec::finish();
    decoder >> proton::codec::finish();
    return decoder;
}

}
}

// Standard serialisers that don't follow the regular AMQP format for various reasons.

namespace java {
namespace security {

class PublicKey : public net::corda::Any {
public:
    proton::binary x509_bits;

    explicit PublicKey(proton::codec::decoder &decoder) {
        decoder >> x509_bits;
    }
};


}  // security

namespace time {

class Instant : public net::corda::Any {
public:
    int64_t epoch_seconds;
    int32_t nanos;

    Instant() : epoch_seconds(0), nanos(0) {}

    explicit Instant(proton::codec::decoder &decoder) : epoch_seconds(0), nanos(0) {
        decoder >> epoch_seconds;
        decoder >> nanos;
    }
};

}
}

#endif
