#include <utility>

#ifndef CORDA_H
#define CORDA_H

#include <iostream>
#include <map>
#include <fstream>
#include <sstream>

#include <proton/codec/decoder.hpp>
#include <proton/types.hpp>

namespace net {
namespace corda {

// TODO: Map kotlin.Pair to std::pair

/**
 * We define a custom name for std::unique_ptr so that we can distinguish in the type system fields that are meant to
 * be coming from the deserialisation engine. This allows us to define overloads to adapt Proton deserialisation to
 * the generated classes, which expect to be given the decoder as a constructor input.
 *
 * @tparam T
 */
template<class T>
class ptr : public std::unique_ptr<T> {
public:
    explicit ptr(T *p) : std::unique_ptr<T>(p) {}

    ptr() : std::unique_ptr<T>() {}
};

/** The root class of a generated message hierarchy. Does nothing. */
class Any {
public:
    virtual ~Any() {};   // Must have at least one virtual function to force vtable generation.
};

enum SchemaDescriptor {
    UNKNOWN = -1,
    ENVELOPE = 1,
    SCHEMA = 2,
    OBJECT_DESCRIPTOR = 3,
    FIELD = 4,
    COMPOSITE_TYPE = 5,
    RESTRICTED_TYPE = 6,
    CHOICE = 7,
    REFERENCED_OBJECT = 8,
    TRANSFORM_SCHEMA = 9,
    TRANSFORM_ELEMENT = 10,
    TRANSFORM_ELEMENT_KEY = 11
};

/**
 * Parses a serialised Corda AMQP message into classes generated by the generate-serialization-libs tool.
 *
 * Can also convert the given message into a debug string dump.
 */
class Parser {
public:
    explicit Parser(const std::string &bytes) : indent_(0), bytes(bytes) {};

    /** Returns a string containing a multi-line debug representation of the message stream. */
    std::string dump();

    template<class T>
    std::unique_ptr<T> parse() {
        proton::codec::decoder decoder = prepare_decoder();
        ptr<T> t;
        decoder >> t;
        decoder >> proton::codec::finish();
        return std::unique_ptr<T>(t.release());
    }

    template<class T>
    inline static void read_to(proton::codec::decoder &decoder, T &out) {
        decoder >> out;
    }

    // We can't add this additional wrapping without read_to.
    template<class T>
    inline static void read_to(proton::codec::decoder &decoder, std::list<ptr<T>> &out) {
        // Unwrap the descriptor surrounding the list.
        proton::codec::start start;
        decoder >> start;
        decoder.next();
        decoder >> out;
        decoder >> proton::codec::finish();
        decoder >> proton::codec::finish();
    }

    template<class K, class V>
    inline static void read_to(proton::codec::decoder &decoder, std::map<K, V> &out) {
        // Unwrap the descriptor surrounding the list.
        proton::codec::start start;
        decoder >> start;
        decoder.next();
        decoder >> out;
        decoder >> proton::codec::finish();
        decoder >> proton::codec::finish();
    }

private:
    const std::string &bytes;
    std::map<proton::symbol, std::string> schema_mappings;
    void resolve_descriptors();

    // Returns bytes_ but with the header truncated if valid, otherwise throws.
    std::string check_corda_amqp();

    proton::codec::decoder prepare_decoder();

    // Dumping support.
    unsigned long indent_;
    std::stringstream ss;

    void dump_process(proton::codec::decoder &decoder, const std::map<proton::symbol, std::string> &schema_mappings, bool need_indent = true, bool need_newline = true);

    void dump_scalar(proton::codec::decoder &decoder, const proton::type_id &type);

    std::string indent() { return std::string(indent_, ' '); }

    void right() { indent_ += 4; }

    void left() { indent_ -= 4; }

    SchemaDescriptor corda_schema_descriptor_id(unsigned long descriptor) {
        // Descriptor IDs start with 0xc562, this is the R3 IANA assigned enterprise number and is used to avoid
        // integer namespace conflicts.
        if ((descriptor & 0xFFFF000000000000L) != (0xc562L << 48))
            return SchemaDescriptor::UNKNOWN;
        else
            return static_cast<SchemaDescriptor>((int) descriptor & 0xFF);
    }
};

/** A quick convenience for parsing bytes to an object. */
template <class T> inline std::unique_ptr<T> parse(const std::string &bytes) { return Parser(bytes).parse<T>(); }
inline std::string dump(const std::string &bytes) { return Parser(bytes).dump(); }

/**
 * A scoped object that verifies the next object in the stream matches the given descriptor, and then sets up the
 * stream for reading by entering the composite type (which is a described list). When it goes out of scope,
 * it will pop up a frame and exit the composite type.
 */
class EnterCompositeType {
public:
    proton::symbol sym;
    proton::codec::start block;

    explicit EnterCompositeType(proton::codec::decoder &decoder, const char *name, bool has_contents);

    virtual ~EnterCompositeType();

protected:
    bool pop_second = false;
    proton::codec::decoder &decoder;
    size_t num_fields = 0;
};

/**
 * Enters a composite type and checks the fingerprint and number of fields is as expected, throws if not.
 */
class CompositeTypeGuard : public EnterCompositeType {
public:
    CompositeTypeGuard(proton::codec::decoder &decoder, const char *name, const proton::symbol &expected, int expected_fields);
};

/**
 * A TypeRegistry maps descriptors to functions that construct objects for them. It allows you to map from descriptor
 * to decoded object. There is a global instance in which the generated code registers itself.
 */
class TypeRegistry {
public:
    static TypeRegistry &GLOBAL();

    typedef std::function<Any*(proton::codec::decoder&)> TypeConstructor;

    void add(const std::string &descriptor, TypeConstructor constructor) {
        registrations.insert(std::make_pair(descriptor, constructor));
    }

    TypeConstructor *get(const std::string &descriptor) {
        if (registrations.find(descriptor) == registrations.end())
            return nullptr;
        else
            return &registrations[descriptor];
    }

private:
    std::map<std::string, TypeConstructor> registrations;
};

/** This class is intended to be instantiated at top level, to auto-register generated types at startup. */
class TypeRegistration {
public:
    explicit TypeRegistration(const char *descriptor, TypeRegistry::TypeConstructor constructor) {
        TypeRegistry::GLOBAL().add(descriptor, constructor);
    }
};

template<class K, class V>
proton::codec::decoder &operator>>(proton::codec::decoder &d, std::map<K, ptr<V>> &r) {
    proton::codec::start s;
    d >> s;
    assert_type_equal(proton::MAP, s.type);
    r.clear();
    for (size_t i = 0; i < s.size / 2; ++i) {
        K k;
        ptr<V> v;
        d >> k >> v;
        r.insert(std::make_pair(k, std::move(v)));
    }
    d >> proton::codec::finish();
    return d;
}

template<class K, class V>
proton::codec::decoder &operator>>(proton::codec::decoder &d, std::map<ptr<K>, ptr<V>> &r) {
    proton::codec::start s;
    d >> s;
    assert_type_equal(proton::MAP, s.type);
    r.clear();
    for (size_t i = 0; i < s.size / 2; ++i) {
        ptr<K> k;
        ptr<V> v;
        d >> k >> v;
        r.insert(std::make_pair(std::move(k), std::move(v)));
    }
    d >> proton::codec::finish();
    return d;
}

template<class K, class V>
proton::codec::decoder &operator>>(proton::codec::decoder &d, std::map<ptr<K>, V> &r) {
    proton::codec::start s;
    d >> s;
    assert_type_equal(proton::MAP, s.type);
    r.clear();
    for (size_t i = 0; i < s.size / 2; ++i) {
        ptr<K> k;
        V v;
        d >> k >> v;
        r.insert(std::make_pair(std::move(k), v));
    }
    d >> proton::codec::finish();
    return d;
}

// Utility to make message formatting a bit less painful. Use like this: msg() << "foo" << bar
struct msg {
    std::ostringstream os;

    msg() {}

    msg(const msg &m) : os(m.str()) {}

    std::string str() const { return os.str(); }

    operator std::string() const { return str(); }

    template<class T>
    msg &operator<<(const T &t) {
        os << t;
        return *this;
    }
};

inline std::ostream &operator<<(std::ostream &o, const msg &m) { return o << m.str(); }

template<class T>
proton::codec::decoder &operator>>(proton::codec::decoder &d, ptr<T> &out) {
    // Enter a composite of unknown type.
    EnterCompositeType entry(d, nullptr, true);
    // Look up a constructor for the descriptor, if we know it.
    auto ctor = TypeRegistry::GLOBAL().get(entry.sym);
    if (ctor == nullptr)
        throw std::invalid_argument(msg() << "Unknown descriptor " << entry.sym << " so cannot construct");
    out = corda::ptr<T>(dynamic_cast<T*>((*ctor)(d)));
    return d;
}

}
}

#endif
